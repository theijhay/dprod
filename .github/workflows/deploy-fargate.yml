name: Deploy to Fargate (Staging)

on:
  push:
    branches: [ staging ]
    paths:
      - 'services/**'
      - 'infrastructure/docker/**'
      - '.github/workflows/deploy-fargate.yml'
  workflow_dispatch: # Allow manual trigger
    inputs:
      service:
        description: 'Service to deploy (api, orchestrator, detection, or all)'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - api
          - orchestrator
          - detection

env:
  AWS_REGION: us-east-1
  ECS_CLUSTER: dprod-staging

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Get AWS Account ID and Generate Build Info
      id: build-info
      run: |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        SHORT_SHA=$(git rev-parse --short HEAD)
        
        echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT
        echo "ecr_registry=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com" >> $GITHUB_OUTPUT
        echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        
    - name: Determine services to build
      id: services
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          SERVICE="${{ github.event.inputs.service }}"
        else
          # Auto-detect changed services based on file paths
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          SERVICE="api"
          
          if echo "$CHANGED_FILES" | grep -q "services/orchestrator\|infrastructure/docker/Dockerfile.orchestrator"; then
            SERVICE="${SERVICE},orchestrator"
          fi
          if echo "$CHANGED_FILES" | grep -q "services/detector\|infrastructure/docker/Dockerfile.detection"; then
            SERVICE="${SERVICE},detection"
          fi
        fi
        
        echo "services=${SERVICE}" >> $GITHUB_OUTPUT
        echo "ðŸ” Will deploy: ${SERVICE}"
        
    - name: Install jq (if needed)
      run: |
        if ! command -v jq &> /dev/null; then
          sudo apt-get update && sudo apt-get install -y jq
        else
          echo "jq is already installed"
        fi
        
    - name: Build and push API image
      if: contains(steps.services.outputs.services, 'api') || steps.services.outputs.services == 'all'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: dprod-api
        TIMESTAMP: ${{ steps.build-info.outputs.timestamp }}
        SHORT_SHA: ${{ steps.build-info.outputs.short_sha }}
      run: |
        echo "ðŸ—ï¸ Building dprod-api..."
        docker build -f infrastructure/docker/Dockerfile.api -t ${ECR_REPOSITORY}:latest -t ${ECR_REPOSITORY}:${TIMESTAMP} -t ${ECR_REPOSITORY}:${SHORT_SHA} .
        
        echo "ðŸ“¤ Pushing to ECR..."
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${TIMESTAMP}
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${SHORT_SHA}
        
    - name: Build and push Orchestrator image
      if: contains(steps.services.outputs.services, 'orchestrator') || steps.services.outputs.services == 'all'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: dprod-orchestrator
        TIMESTAMP: ${{ steps.build-info.outputs.timestamp }}
        SHORT_SHA: ${{ steps.build-info.outputs.short_sha }}
      run: |
        echo "ðŸ—ï¸ Building dprod-orchestrator..."
        docker build -f infrastructure/docker/Dockerfile.orchestrator -t ${ECR_REPOSITORY}:latest -t ${ECR_REPOSITORY}:${TIMESTAMP} -t ${ECR_REPOSITORY}:${SHORT_SHA} .
        
        echo "ðŸ“¤ Pushing to ECR..."
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${TIMESTAMP}
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${SHORT_SHA}
        
    - name: Build and push Detection image
      if: contains(steps.services.outputs.services, 'detection') || steps.services.outputs.services == 'all'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: dprod-detection
        TIMESTAMP: ${{ steps.build-info.outputs.timestamp }}
        SHORT_SHA: ${{ steps.build-info.outputs.short_sha }}
      run: |
        echo "ðŸ—ï¸ Building dprod-detection..."
        docker build -f infrastructure/docker/Dockerfile.detection -t ${ECR_REPOSITORY}:latest -t ${ECR_REPOSITORY}:${TIMESTAMP} -t ${ECR_REPOSITORY}:${SHORT_SHA} .
        
        echo "ðŸ“¤ Pushing to ECR..."
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${TIMESTAMP}
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${SHORT_SHA}
        
    - name: Update ECS Task Definition and Deploy - API
      if: contains(steps.services.outputs.services, 'api') || steps.services.outputs.services == 'all'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        TIMESTAMP: ${{ steps.build-info.outputs.timestamp }}
      run: |
        IMAGE_URI="${ECR_REGISTRY}/dprod-api:${TIMESTAMP}"
        
        echo "ðŸ”„ Updating ECS task definition for dprod-api..."
        
        # Get current task definition
        TASK_DEF=$(aws ecs describe-task-definition --task-definition dprod-api --query 'taskDefinition' --output json)
        
        # Update image URI in container definitions
        NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$IMAGE_URI" '(.containerDefinitions[0].image = $IMAGE) | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
        
        # Register new task definition
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json "$NEW_TASK_DEF" \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "âœ… New task definition: ${NEW_TASK_DEF_ARN}"
        
        # Update service to use new task definition
        echo "ðŸš€ Deploying to ECS service dprod-api..."
        aws ecs update-service \
          --cluster ${ECS_CLUSTER} \
          --service dprod-api \
          --task-definition ${NEW_TASK_DEF_ARN} \
          --force-new-deployment \
          --query 'service.serviceArn' \
          --output text
        
        echo "âœ… Deployment initiated for dprod-api"
        
    - name: Update ECS Task Definition and Deploy - Orchestrator
      if: contains(steps.services.outputs.services, 'orchestrator') || steps.services.outputs.services == 'all'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        TIMESTAMP: ${{ steps.build-info.outputs.timestamp }}
      run: |
        IMAGE_URI="${ECR_REGISTRY}/dprod-orchestrator:${TIMESTAMP}"
        
        echo "ðŸ”„ Updating ECS task definition for dprod-orchestrator..."
        
        # Get current task definition
        TASK_DEF=$(aws ecs describe-task-definition --task-definition dprod-orchestrator --query 'taskDefinition' --output json 2>/dev/null || echo "{}")
        
        if [ "$TASK_DEF" != "{}" ]; then
          # Update image URI in container definitions
          NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$IMAGE_URI" '(.containerDefinitions[0].image = $IMAGE) | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "âœ… New task definition: ${NEW_TASK_DEF_ARN}"
          
          # Update service (if exists)
          aws ecs update-service \
            --cluster ${ECS_CLUSTER} \
            --service dprod-orchestrator \
            --task-definition ${NEW_TASK_DEF_ARN} \
            --force-new-deployment \
            --query 'service.serviceArn' \
            --output text 2>/dev/null || echo "âš ï¸ Service dprod-orchestrator does not exist, skipping deployment"
        else
          echo "âš ï¸ Task definition dprod-orchestrator does not exist, skipping"
        fi
        
    - name: Update ECS Task Definition and Deploy - Detection
      if: contains(steps.services.outputs.services, 'detection') || steps.services.outputs.services == 'all'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        TIMESTAMP: ${{ steps.build-info.outputs.timestamp }}
      run: |
        IMAGE_URI="${ECR_REGISTRY}/dprod-detection:${TIMESTAMP}"
        
        echo "ðŸ”„ Updating ECS task definition for dprod-detection..."
        
        # Get current task definition
        TASK_DEF=$(aws ecs describe-task-definition --task-definition dprod-detection --query 'taskDefinition' --output json 2>/dev/null || echo "{}")
        
        if [ "$TASK_DEF" != "{}" ]; then
          # Update image URI in container definitions
          NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$IMAGE_URI" '(.containerDefinitions[0].image = $IMAGE) | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "âœ… New task definition: ${NEW_TASK_DEF_ARN}"
          
          # Update service (if exists)
          aws ecs update-service \
            --cluster ${ECS_CLUSTER} \
            --service dprod-detection \
            --task-definition ${NEW_TASK_DEF_ARN} \
            --force-new-deployment \
            --query 'service.serviceArn' \
            --output text 2>/dev/null || echo "âš ï¸ Service dprod-detection does not exist, skipping deployment"
        else
          echo "âš ï¸ Task definition dprod-detection does not exist, skipping"
        fi
        
    - name: Wait for deployment to complete
      if: contains(steps.services.outputs.services, 'api') || steps.services.outputs.services == 'all'
      run: |
        echo "â³ Waiting for deployment to stabilize..."
        aws ecs wait services-stable \
          --cluster ${ECS_CLUSTER} \
          --services dprod-api || echo "âš ï¸ Deployment check completed"
        
    - name: Deployment Summary
      run: |
        echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Services deployed:** ${{ steps.services.outputs.services }}" >> $GITHUB_STEP_SUMMARY
        echo "**Cluster:** ${ECS_CLUSTER}" >> $GITHUB_STEP_SUMMARY
        echo "**Region:** ${AWS_REGION}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âœ… Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY

